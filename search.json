[{"title":"C++ Coroutine: 通用异步任务 Task","path":"/posts/3692590940/","content":"代码源自：https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/ 这段代码使用协程实现了一个通用的异步任务执行类 Task，支持设置回调函数并将在 Task 完成后执行回调。 Task、TaskPromise 和 TaskAwaiter 覆盖到了大部分的协程执行过程，把这几个类的实现理解了那基本上就可以说已经理解了 c++ 协程的工作方式。 阅读下面这段代码的方式建议通过 main 函数开始，对照运行结果一点一点来看。 Source Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#include &lt;iostream&gt;#include &lt;coroutine&gt;#include &lt;functional&gt;#include &lt;exception&gt;#include &lt;optional&gt;#include &lt;atomic&gt;#include &lt;utility&gt;#include &lt;chrono&gt;#include &lt;thread&gt;#include &lt;list&gt;#include &lt;condition_variable&gt;#include &lt;algorithm&gt;#include &lt;atomic&gt;#define debug(info) std::cout &lt;&lt; __LINE__ &lt;&lt; &quot; &quot; &lt;&lt; __func__ &lt;&lt; &quot;: &quot; &lt;&lt; info &lt;&lt; std::endl;template&lt;typename Task&gt;struct Result&#123; // 初始化为默认值 explicit Result() = default; // 当 Task 正常返回时用结果初始化 Result explicit Result(Task &amp;&amp;value) : _value(value) &#123; debug(&quot;Construct from value&quot;); &#125; // 当 Task 抛异常时用异常初始化 Result explicit Result(std::exception_ptr &amp;&amp;exception_ptr) : _exception_ptr(exception_ptr) &#123; debug(&quot;Construct from exception_ptr&quot;); &#125; // 读取结果，有异常则抛出异常 Task get_or_throw() &#123; if (_exception_ptr) &#123; std::rethrow_exception(_exception_ptr); &#125; return _value; &#125; private: Task _value&#123;&#125;; std::exception_ptr _exception_ptr;&#125;;template&lt;template&lt;typename&gt; class Task, typename R&gt;struct TaskAwaiter &#123; explicit TaskAwaiter(Task&lt;R&gt; &amp;&amp;task) noexcept : task(std::move(task)) &#123; debug(&quot;Construct from task&quot;); &#125; TaskAwaiter(TaskAwaiter &amp;&amp;completion) noexcept : task(std::exchange(completion.task, &#123;&#125;)) &#123; debug(&quot;Construct from completion&quot;); &#125; TaskAwaiter(TaskAwaiter &amp;) = delete; TaskAwaiter &amp;operator=(TaskAwaiter &amp;) = delete; constexpr bool await_ready() const noexcept &#123; debug(&quot;&quot;); return false; &#125; void await_suspend(std::coroutine_handle&lt;&gt; handle) noexcept &#123; debug(&quot;&quot;); std::cout &lt;&lt; handle.address() &lt;&lt; std::endl; // 当 task 执行完之后调用 resume task.finally([handle]() &#123; handle.resume(); &#125;); &#125; // 协程恢复执行时，被等待的 Task 已经执行完，调用 get_result 来获取结果 R await_resume() noexcept &#123; debug(&quot;&quot;); return task.get_result(); &#125; private: Task&lt;R&gt; task;&#125;;template&lt;template&lt;typename&gt; class Task, typename ResultType&gt;struct TaskPromise&#123; auto initial_suspend() noexcept &#123; debug(&quot;&quot;); return std::suspend_never&#123;&#125;; &#125; auto final_suspend() noexcept &#123; debug(&quot;&quot;); return std::suspend_always&#123;&#125;; &#125; Task&lt;ResultType&gt; get_return_object() &#123; return Task&#123;std::coroutine_handle&lt;TaskPromise&gt;::from_promise(*this)&#125;; &#125; void unhandled_exception() &#123; debug(&quot;&quot;); std::lock_guard lock(completion_lock); result = Result&lt;ResultType&gt;(std::current_exception()); completion.notify_all(); // 调用回调 notify_callbacks(); &#125; void return_value(ResultType value) &#123; debug(&quot;&quot;); std::lock_guard lock(completion_lock); result = Result&lt;ResultType&gt;(std::move(value)); completion.notify_all(); // 调用回调 notify_callbacks(); &#125; ResultType get_result() &#123; debug(&quot;from TaskPromise&quot;); // 如果 result 没有值，说明协程还没有运行完，等待值被写入再返回 std::unique_lock lock(completion_lock); if (!result.has_value()) &#123; debug(&quot;hasn&#x27;t value now&quot;); // 等待写入值之后调用 notify_all completion.wait(lock); &#125; else &#123; debug(&quot;already has value now&quot;); &#125; // 如果有值，则直接返回（或者抛出异常） return result-&gt;get_or_throw(); &#125; void on_completed(std::function&lt;void(Result&lt;ResultType&gt;)&gt; &amp;&amp;func) &#123; debug(&quot;&quot;); std::unique_lock lock(completion_lock); // 加锁判断 result if (result.has_value()) &#123; debug(&quot;already has value&quot;); // result 已经有值 auto value = result.value(); // 解锁之后再调用 func lock.unlock(); func(value); &#125; else &#123; debug(&quot;waiting for execution&quot;); // 否则添加回调函数，等待调用 completion_callbacks.push_back(func); &#125; &#125; // 注意这里的模板参数 template&lt;typename _ResultType&gt; auto await_transform(Task&lt;_ResultType&gt; &amp;&amp;task) &#123; debug(&quot;&quot;); return TaskAwaiter&lt;Task, _ResultType&gt;&#123;std::move(task)&#125;; &#125; private: // 回调列表，我们允许对同一个 Task 添加多个回调 std::list&lt;std::function&lt;void(Result&lt;ResultType&gt;)&gt;&gt; completion_callbacks; void notify_callbacks() &#123; debug(&quot;&quot;); auto value = result.value(); for (auto &amp;callback : completion_callbacks) &#123; debug(&quot;call callback function from completion_callbacks&quot;); callback(value); &#125; // 调用完成，清空回调 completion_callbacks.clear(); &#125; // 使用 std::optional 可以区分协程是否执行完成 std::optional&lt;Result&lt;ResultType&gt;&gt; result; std::mutex completion_lock; std::condition_variable completion;&#125;;template&lt;typename ResultType&gt;struct Task&#123; // 声明 promise_type 为 TaskPromise 类型 using promise_type = TaskPromise&lt;Task, ResultType&gt;; ResultType get_result() &#123; debug(&quot;from Task&quot;); return handle.promise().get_result(); &#125; Task &amp;then(std::function&lt;void(ResultType)&gt; &amp;&amp;func) &#123; debug(&quot;task id = &quot; + std::to_string(task_id)); std::cout &lt;&lt; handle.address() &lt;&lt; std::endl; handle.promise().on_completed([func](auto result) &#123; try &#123; func(result.get_or_throw()); &#125; catch (std::exception &amp;e) &#123; // 忽略异常 &#125; &#125;); return *this; &#125; Task &amp;catching(std::function&lt;void(std::exception &amp;)&gt; &amp;&amp;func) &#123; debug(&quot;task id = &quot; + std::to_string(task_id)); handle.promise().on_completed([func](auto result) &#123; try &#123; // 忽略返回值 result.get_or_throw(); &#125; catch (std::exception &amp;e) &#123; func(e); &#125; &#125;); return *this; &#125; Task &amp;finally(std::function&lt;void()&gt; &amp;&amp;func) &#123; debug(&quot;task id = &quot; + std::to_string(task_id)); std::cout &lt;&lt; handle.address() &lt;&lt; std::endl; handle.promise().on_completed([func](auto result) &#123; func(); &#125;); return *this; &#125; explicit Task(std::coroutine_handle&lt;promise_type&gt; handle) noexcept: handle(handle), task_id(cnt) &#123; ++cnt; debug(&quot;Construct from handle, task id = &quot; + std::to_string(task_id)); std::cout &lt;&lt; handle.address() &lt;&lt; std::endl; &#125; Task(Task &amp;&amp;task) noexcept: handle(std::exchange(task.handle, &#123;&#125;)), task_id(cnt) &#123; ++cnt; debug(&quot;Move Construct from task, task id = &quot; + std::to_string(task.task_id) &lt;&lt; &quot;-&gt;&quot; &lt;&lt; std::to_string(task_id)); std::cout &lt;&lt; handle.address() &lt;&lt; std::endl; &#125; Task(Task &amp;) = delete; Task &amp;operator=(Task &amp;) = delete; ~Task() &#123; if (handle) handle.destroy(); &#125; private: std::coroutine_handle&lt;promise_type&gt; handle; static std::atomic&lt;int&gt; cnt; const int task_id;&#125;;template &lt;typename T&gt;std::atomic&lt;int&gt; Task&lt;T&gt;::cnt = 0;Task&lt;int&gt; simple_task2() &#123; debug(&quot;task 2 start ...&quot;); using namespace std::chrono_literals; std::this_thread::sleep_for(1s); debug(&quot;task 2 returns after 1s.&quot;); co_return 2;&#125;Task&lt;int&gt; simple_task3() &#123; debug(&quot;in task 3 start ...&quot;); using namespace std::chrono_literals; std::this_thread::sleep_for(2s); debug(&quot;task 3 returns after 2s.&quot;); co_return 3;&#125;Task&lt;int&gt; simple_task() &#123; debug(&quot;task start ...&quot;); auto result2 = co_await simple_task2(); debug(&quot;returns from task2: &quot; + std::to_string(result2)); auto result3 = co_await simple_task3(); debug(&quot;returns from task3: &quot; + std::to_string(result3)); co_return 1 + result2 + result3;&#125;int main() &#123; auto simpleTask = simple_task(); std::cout &lt;&lt; &quot;======================&quot; &lt;&lt; std::endl; simpleTask.then([](int i) &#123; debug(&quot;simple task end: &quot; + std::to_string(i)); &#125;).catching([](std::exception &amp;e) &#123; debug(&quot;error occurred&quot; + std::string&#123;e.what()&#125;); &#125;); std::cout &lt;&lt; &quot;======================&quot; &lt;&lt; std::endl; try &#123; auto i = simpleTask.get_result(); debug(&quot;simple task end from get: &quot; + std::to_string(i)); &#125; catch (std::exception &amp;e) &#123; debug(&quot;error: &quot; + std::string&#123;e.what()&#125;); &#125; return 0;&#125; 运行结果分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110ASM generation compiler returned: 0Execution build compiler returned: 0Program returned: 0// 这里通过 auto simpleTask = simple_task(); 构建第一个 Task1 0x5562ea17feb0250 Task: Construct from handle, task id = 00x5562ea17feb0// 构建协程类第一步 initial_suspend100 initial_suspend: // 这里因为 suspend_never 所以继往下走295 simple_task: task start ...// 通过 auto result2 = co_await simple_task2(); 构建第二个 Task2 0x5562ea180fe0250 Task: Construct from handle, task id = 10x5562ea180fe0100 initial_suspend: 279 simple_task2: task 2 start ...282 simple_task2: task 2 returns after 1s.// 一直走到 co_return 2; 进入 TaskPromise::return_value126 return_value: // 通过 result = Result&lt;ResultType&gt;(std::move(value)); 用 value(2) 构建了一个 Result26 Result: Construct from value// 中间调了 completion.notify_all(); 但是这里没有 wait// 继续在 TaskPromise::return_value 中 notify_callbacks();181 notify_callbacks: // co_return 之后这个协程 0x5562ea180fe0 就结束了 (还没释放，因为 finial 是 suspend_always)105 final_suspend: // 这里把 co_return 的结果给到 Task1 的 TaskPromise170 await_transform: // await_transform 返回一个 TaskAwaiter, 把刚刚的 Task2 存起来了（移动拷贝）257 Task: Move Construct from task, task id = 1-&gt;20x5562ea180fe055 TaskAwaiter: Construct from task// 这里先判断 ready, 直接返回 false70 await_ready: // false 的情况下需要 suspend (注意这里传入的参数 handle 是 Task1 的 handle)76 await_suspend: 0x5562ea17feb0// 这里 task.finally([handle]() &#123; 就是刚刚存起来的 Task2// 传了一个回调去 handle.resume();241 finally: task id = 20x5562ea180fe0// handle.promise().on_completed([func](auto result) &#123; func(); &#125;);149 on_completed: // 这里判断了一下 result 有没有值, 那么这里因为是 Task2 的 Promise // 所以 result 在刚刚 return_value 填充上了153 on_completed: already has value// 这里是通过刚刚的回调调到的 Task1 Promise 的 handle.resume()87 await_resume: // 这里 return task.get_result(); 这里的 task 是刚刚传到 TaskAwaiter 的 Task2207 get_result: from Task136 get_result: from TaskPromise// 这里还是一样的 result 是 value(2)144 get_result: already has value now// 这里因为 TaskAwaiter 在 finally 中 resume 了 Task1 的 handle 所以继续进行297 simple_task: returns from task2: 2// 通过 auto result3 = co_await simple_task3(); 构建 Task3 0x5562ea180fe0250 Task: Construct from handle, task id = 30x5562ea180fe0// 后面 Task3 执行和返回的过程大部分都一样的100 initial_suspend: 287 simple_task3: in task 3 start ...290 simple_task3: task 3 returns after 2s.126 return_value: 26 Result: Construct from value181 notify_callbacks: 105 final_suspend: 170 await_transform: 257 Task: Move Construct from task, task id = 3-&gt;40x5562ea180fe055 TaskAwaiter: Construct from task70 await_ready: 76 await_suspend: 0x5562ea17feb0241 finally: task id = 40x5562ea180fe0149 on_completed: 153 on_completed: already has value87 await_resume: 207 get_result: from Task136 get_result: from TaskPromise144 get_result: already has value now// 一直到这里同样 Task1 通过 Task3 的回调被 resume 继续执行299 simple_task: returns from task3: 3// 这里 co_return 1 + result2 + result3; 调到 return_value126 return_value: // 这里和前面一样同样构建了 Result26 Result: Construct from value181 notify_callbacks: // 这里 Task 也走完了, suspend105 final_suspend: ======================// 刚刚所有的过程只在声明了 simpleTask 之后就执行完了// 接着调用 simpleTask.then()213 then: task id = 00x5562ea17feb0// 那这里同样之前已经有值了149 on_completed: 153 on_completed: already has value// 这里通过 on_completed 调回到 lambda 回调 debug(&quot;simple task end: &quot; + std::to_string(i));306 operator(): simple task end: 6// 这里 catch 了一下异常，但是因为没有异常所以没有触发 debug(&quot;error: &quot; + std::string&#123;e.what()&#125;);227 catching: task id = 0149 on_completed: 153 on_completed: already has value======================// try-catch 里的逻辑也类似207 get_result: from Task136 get_result: from TaskPromise144 get_result: already has value now313 main: simple task end from get: 6","tags":["c++20","coroutine"]},{"title":"Windows7 下安装 Oracle RAC11gR2","path":"/posts/324638463/","content":"本文介绍了如何在 Window7 环境下安装 Oracle RAC11gR2 的方法以及安装过程中遇到的一些问题的解决方法 资源 win64_11gR2_grid win64_11gR2_database_1of2 win64_11gR2_database_2of2 以上资源可在官网下载 安装文档以 Rac11gR2OnWindows.pdf 为准，由于文档上面有很多步骤比较省略，且更接近真实环境下的配置方案，因此找了 一篇安装步骤非常接近官方文档的博客1作为参考，同时结合其他博客进行安装 首先给出网络拓扑结构如下，后面遇到问题可以返回来作为参照 正式开始配置 配置步骤虚拟机准备 创建一个 Windows7 虚拟机（使用 VMware® Workstation 15 pro） 安装 jdk （版本应在 1.5 及以上） 为虚拟机添加一块网卡 克隆虚拟机 ✴︎节点名称配置修改主机名、统一用户名密码，分别更改两台服务器的主机名为 cluster1 和 cluster2，需要重启后生效，两台服务器统一使用 administrator 用户，并且保持密码一致。 修改主机名在“资源管理器-&gt;右键（计算机）-&gt;属性-&gt;更改设置（计算机名称、与和工作组）-&gt;更改“，保存后重启即可 用户必须使用 administrator 用户，需要在“资源管理器-&gt;右键（计算机）-&gt;管理-&gt;本地用户和组“中开启并设置密码 对所有节点执行上述操作，保证各节点 administrator 账户的密码相同，后续操作同样需要在 administrator 账户下进行，重启后注意切换用户 配置本地安全策略 运行 secpol.msc ,配置”安全设置-&gt;本地策略-&gt;安全选项-&gt;用户帐户控制:管理员批准模式中管理员的提升权限提示的行为”为”不提示，直接提升”。 确认”安全设置-&gt;本地策略-&gt;用户权限分配-&gt;管理审核和安全日志”中包括 Administrators 组。 运行 firewall.cpl ,关闭防火墙。 关闭防火墙需要在 “cmd-&gt;firewall.cp-&gt;高级设置-&gt;防火墙属性” 中确定防火墙状态为关闭 测试 net use在每个节点执行 net use \\\\remote node name\\C$ 提示命令成功完成则正确，否则不正确 &gt;&gt;执行net use失败&lt;&lt; 远程注册表连接测试运行 regedit ,选择 “文件-&gt;连接网络注册表-&gt;输入远程节点nodename” 出现注册表结构树,测试成功.(所有节点执行) ✴︎配置网络 在“网络和共享中心-&gt;更改适配器设置”中将网络适配器的名称改为”net0”和”net1” 按照拓扑图修改ip地址（net0为公网，net1为私网） 示例： cluster1： net0 -&gt; Public IP: 192.168.40.230&#x2F;24 net1 -&gt; Private IP: 10.0.0.95&#x2F;24 cluster2: net0 -&gt; Public IP: 192.168.40.232&#x2F;24 net1 -&gt; Private IP:10.0.0.97&#x2F;24 在“网络和共享中心-&gt;更改适配器设置-&gt;（按下alt）高级-&gt;高级设置”中修改连接顺序为net0-&gt;net1-&gt;… 修改hosts文件：位于C:\\Windows\\System32\\drivers\\etc 示例： #public 192.168.40.230 cluster1 192.168.40.232 cluster2 #private 10.0.0.95 cluster1-priv 10.0.0.97 cluster2-priv #vip 192.168.40.231 cluster1-vip 192.168.40.233 cluster2-vip #scan 192.168.40.234 cluster-scan 使用ping验证hosts文件修改是否成功 关闭DHCP媒体感知打开注册表定位到 HKLM\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters 子项,新建一个 DWORD 类型的键值 DisableDHCPMediaSense ,将值修改为 1. 重启后使用命令 netsh interface ipv4 show global 验证是否成功关闭. 关闭SNP Features12C:\\&gt;netsh int tcp set global chimney=disabledC:\\&gt;netsh int tcp set global rss=disabled 重启后使用命令 C:\\&gt;netsh interface ipv4 show global 验证是否成功关闭 停止MSDTC服务运行 services.msc ,将 Distributed Transaction Coordinator (MSDTC) 服务停止,并设为”手动”. 同步节点时间1、运行 Regedit 定位到 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\W32Time\\Config 子项,将主键 MaxNegPhaseCorrection 数值修改为0,关闭注册表程序. 执行同步: C:\\&gt;W32tm /config /update (需要连接Internet) 2、或者：在 RAC2 服务器上运行命令：net time \\rac1 (查看 RAC1 的当前时间)然后在 RAC2 服务器上运行命令：net time \\rac1 /set /y (设置 RAC2 时间与 RAC1 同 步)（建议使用这种方式） 检查环境变量计算机 右键-&gt;属性-&gt;高级系统设置-&gt;环境变量,确认变量TMP和TEMP值相同. 配置 DEP 和 UAC1、分别配置两台服务器上的数据执行保护（DEP），选择‘仅为基本 windows程序和服务启用’，需要重启后才能生效（可配置完下一步后一起重启） 确认两台服务器上的 UAC，若需要配置则在重启后生效(默认不需要配置) 修改虚拟内存由于服务器的内存为 16G，按照 Oracle 的官方文档，虚拟内存至少为实际内 存的 2 倍，此处选择在本地磁盘一个较大的空白分区（E 盘）中划分了虚拟 内存，取值范围：32G~64G，即初始值：32768MB，最大值：65536MB ✴︎配置共享磁盘 这一步与使用的虚拟机及其版本有关，这里使用的是VMware® Workstation 15 pro，使用其他如VirtualBox请自行搜索配置方式 在虚拟机中添加2块磁盘分别用作OCR_VOTE（表决磁盘）以及DATA（数据磁盘）： 虚拟磁盘类型：SCSI(S) →创建新的虚拟磁盘（第一次创建，之后使用现有的虚拟磁盘） →磁盘大小（OCR：4G，DATA：16G，FRA：8G（如果有））、立即分配、存储为单个文件 在“虚拟机设置→选中硬盘→高级”中将新添加的虚拟设备节点按照顺序设为SCSI 1:x 在其他节点中添加相同数量的虚拟磁盘，并将设备节点一一对应设置 打开虚拟机文件（xxx.vmx）添加如下行（注意删除已存在的重复行）： 1234567891011disk.locking=&quot;FALSE&quot;disk.EnableUUID = &quot;TRUE&quot;diskLib.dataCacheMaxSize = &quot;0&quot;diskLib.dataCacheMaxReadAheadSize = &quot;0&quot;diskLib.dataCacheMinReadAheadSize = &quot;0&quot;diskLib.dataCachePageSize = &quot;0&quot;diskLib.maxUnsyncedWrites = &quot;0&quot;scsi1.shared=&quot;TRUE&quot;scsi1.virtualDev = &quot;lsilogic&quot;scsi1.sharedBus = &quot;VIRTUAL&quot;scsi1.present = &quot;TRUE&quot; 并在克隆的虚拟机vmx文件中额外添加如下行（取决于磁盘数量）： 123scsi1:0.mode = &quot;independent-persistent&quot;scsi1:1.mode = &quot;independent-persistent&quot;... 配置完成后重新打开“虚拟机设置”中可以看到克隆机显示磁盘为（独立） &gt;&gt;可能存在的问题&lt;&lt; 开机，在“计算机→（右键）管理→磁盘管理”中可以看到刚刚添加的磁盘，同时会提示需要对磁盘进行初始化（没有弹出提示的话可以手动全部选中，点击右键→初始化磁盘），并选择使用GPT初始化 为每一个节点执行上一步操作 为每一块磁盘选择“右键→新建简单卷→不分配驱动器号或驱动器路径→不要格式化这个卷“ 完成后应该显示磁盘为RAW设备 在另一台虚拟机上打开磁盘管理重新扫描磁盘即可 &gt;&gt;共享磁盘显示不正确&lt;&lt; 启用Automount (All Nodes)进行命令行窗口,运行: 12C:\\&gt; diskpartDISKPART&gt; AUTOMOUNT ENABLE 标记ASM磁盘在cluster1执行以下命令（cd至 grid安装目录\\asmtool） 1E:\\grid\\asmtool&gt;asmtoolg.exe 在弹出的图形化界面中进行以下操作： 选择“Add or change label“ →选中作为表决磁盘的虚拟硬盘 →修改下方标记为“OCR” →点击下一步 这一步只需在cluster1节点下操作，并且此时只标记OCR磁盘组，用于DATA组的硬盘暂不处理 ✴︎安装Grid Infrastructure (cluster1)执行预检查 D:\\11\\grid&gt;runcluvfy stage -pre crsinst -n rac1,rac2 -verbose 如果有报错,检查修改前面的设置直到预检查成功 在grid目录下执行setup.exe程序 选择“跳过软件更新” 选择‘为集群安装和配置 集群的网络基础结构’ 选择‘高级安装’ 选择安装语言 填写集群名称和 SCAN 名称，必须填写 hosts 文件中 SCAN IP 对应的主机名,确认去掉“配置GNS”复选框。 示例： 集群名称：mer-cluster scan名称：cluster-scan scan端口：1521 添加其他节点（应当显示cluster1和cluster2） 更改网络接口类型，默认选项如果不对，需要手动更改 此处选择‘自动存储管理（ASM） 选择相应的OCR磁盘组，并输入磁盘组名称OCR 示例： 磁盘组名：OCR 冗余：外部 添加磁盘：候选磁盘（选择标记为OCR的磁盘路径） 添加 ASM （ASMSnmp）口令（topsec） 由于设置的密码不符合标准，需要确认来强制使用 此处选择‘不使用 IPMI 选择软件相关目录 示例： Oracle基目录：C:\\app\\Administrator 软件位置：C:\\app\\11.2.0\\grid 先决条件检查，如果检查通过，则出现概要，如果提示失败，会有相应的提示，请根据提示 检查之前步骤中的设置是否存在问题 开始安装后，会在”网格基础结构配置“处停顿较长时间，此处也是 grid 安装成功与否的关键所在，如果此处出现问题，则需要 卸 载 grid，并检查之前所有的设置，然后再次尝试安装，直到显示成功为止。 安装成功完成 检查ora.asm资源运行状态grid 安装完成后，如果安装成功，可在 dos 环境下通过 crs_stat –t –v 命令或者 crsctl status res -t 查看集 群启动了哪 些服务 ✴︎安装RDBMS（cluster1）执行预检查 D:\\grid&gt;runcluvfy stage -pre dbinst -n rac1,rac2 -verbose 开始安装 执行database目录下setup.exe程序 确认跳过‘指定电子邮件地址 选择“跳过软件更新” 选择‘仅安装数据库软件 查看节点名称是否正确 选择安装语言 选择安装企业版，并且勾选所有组件 选择安装路径 示例： Oracle基目录：C:\\app\\Administrator 软件位置：C:\\app\\Administrator\\product\\11.2.0\\db_home1 先决条件检查 安装概要 安装到此处时，执行远程安装 RAC2 节点的数据库，此时等待时间会很长， 请耐心等待 ✴︎安装完成后需要根据提示在cluster2节点上执行操作（注意别随手关闭提示） C:\\app\\Administrator\\product\\11.2.0\\dbhome_1\\BIN\\selecthome.bat 执行过程中出现的计数器尚未安装可以忽略 &gt;&gt;安装RDBMS失败（不要关闭提示窗口）&lt;&lt; 使用ASMCA创建ASM磁盘组 在命令行下执行asmca 在磁盘组选项卡中点击新建 单击在磁盘上加载标记 参考标记OCR的方式标记DATA磁盘 标记完成后填写磁盘组为DATA，冗余为外部，选择标记的磁盘，点击确定 创建磁盘组 按照相同的方法标记和创建 FRA 磁盘组（有需要的话） 创建完成后退出. ✴︎创建数据库执行预检查 D:\\grid&gt;runcluvfy stage -pre dbcfg -n all -d D:\\app\\Administrator\\product\\11.2.0\\db1 创建数据库 D:\\&gt;dbca &gt;&gt;找不到dbca命令&lt;&lt; 选择RAC数据库 选择创建数据库 一般用途或事务处理 配置数据库标示 示例： 配置类型：管理员管理的 全局数据库名：mer SID前缀：mer 单击全选 配置管理选项 示例： 勾选配置Enterprise Manager 选择配置Database Control进行本地管理 不勾选预警通知与每日备份 对所有账户使用同一管理口令 使用Oracle-Managed Files，选择数据库区为刚刚标记的DATA磁盘组 输入之前设置的ASM口令 取消勾选快速恢复区 配置字符集→从字符集列表中选择→”ZHS16GBK - GBK16位简体中文“ 数据库存储 创建数据库 数据库概要 等待创建完成 &gt;&gt;数据库创建失败&lt;&lt; 数据库创建完成中可能弹出提示如下: 此时按照提示在相应节点上（此处为cluster2）执行命令： 首先确定dbconsole状态： ​ C:\\&gt;emctl status dbconsole 若显示：Environment variable ORACLE_UNQNAME not defined. Please define it. 则设置环境变量ORACLE_UNQNAME: ​ C:\\&gt;set ORACLE_UNQNAME&#x3D;mer 若提示其他（如sid）未定义，则也设置相应的值 之后执行提示的第二步命令： ​ C:\\…\\db_home\\bin\\emctl.bat start dbconsole 执行完毕后回到cluster1节点点击确定提示集群数据库创建完成，并返回管理url 点击口令管理，解锁scott账户，设定密码 至此集群安装完成，在web端输入db control url即可访问管理登录界面，使用 用户名：SYSTEM 密码：topsec（之前设置的统一管理密码） 即可登录到集群管理界面 &gt;&gt;登录失败&lt;&lt; 可能遇到的问题及解决方法1、执行net use失败 错误号5，拒绝访问：很可能你使用的用户不是管理员权限的，先提升权限；错误号51，Windows无法找到网络路径：网络有问题；错误号53，找不到网络路径：ip地址错误；目标未开机；目标lanmanserver服务未启动；目标有防火墙（端口过滤）；错误号67，找不到网络名：你的lanmanworkstation服务未启动或者目标删除了ipc$；错误号1219，提供的凭据与已存在的凭据集冲突：你已经和对方建立了一个ipc$，请删除再连；错误号1326，未知的用户名或错误密码：原因很明显了；错误号1792，试图登录，但是网络登录服务没有启动：目标NetLogon服务未启动；错误号2242，此用户的密码已经过期：目标有帐号策略，强制定期要求更改密码； 确定当前登录用户为administrator 确定已为administrator用户设定密码 执行net share确定包含C$ 在”Windows+R”中执行secpol.msc，确定“安全设置→本地策略→安全选项”中“网络访问：本地账户的共享和安全模型”设置为“经典：对本地用户…“ 2、vmx文件中可能存在的问题 在多数的博客中，设置disk.EnableUUID与scsi1.virtualDev的值为如下 12disk.EnableUUID = &quot;TRUE&quot;scsi1.virtualDev = &quot;lsilogic&quot; 但在少数博客中将这个值设置（或保持原来的值）为 12disk.EnableUUID = &quot;FALSE&quot;scsi1.virtualDev = &quot;lsisas1068&quot; 经测试这两种值似乎不影响共享磁盘的效果，但这里仍旧推荐使用第一种的配置值 3、共享磁盘显示不正确 检查是否所有节点都显示磁盘以联机，尝试重新配置 4、安装RDBMS失败 预检查成功，但安装时提示对于节点磁盘空间的先决检查失败 可以忽略该问题，对后续安装过程不造成影响 安装中途cluster2死机或重启导致安装中断 暂时不要关闭提示窗口，重启cluster2并切换至administrator账户，等待至集群服务启动后（各vip、scan-ip可以ping通）返回cluster1点击确定可以继续安装 所选安装与指定 Oracle 主目录中已安装的软件冲突 的问题 正确的做法是卸载RDBMS，清除相关文件、注册表以及服务并重新安装，但是没有找到相关的文档，删除所有Oracle项又会对以安装的grid项造成影响，因此此处选择修改数据库软件安装路径，将dbhome_1修改为dbhome_2，修改后可能会出现“无法启动&#x2F;关闭&#x2F;找到指定路径 OracleMTSRecoveryService”，解决方法同下 OracleMTSRecoveryService 无法启动&#x2F;关闭&#x2F;找到指定路径 首先打开Win+R，“（输入）services.msc→（找到）OracleMTSRecoveryService “，若该服务不存在则不适用于下述解决方法，初次安装时提示无法启动不适用 确定该服务存在并确定其启动类型为自动后，打开Win+R，“（输入）regedit→（找到）HKEY_LOCAL_MACHINE→SYSTEM→CurrentControlSet→services→OracleMTSRecoveryService”，修改ImagePath的值为新的安装路径（dbhome_2），并对以下位置进行同样的修改： HKEY_LOCAL_MACHINE→SYSTEM→CurrentControlSet→services→OracleMTSRecoveryService HKEY_LOCAL_MACHINE→SYSTEM→ControlSet001→services→OracleMTSRecoveryService HKEY_LOCAL_MACHINE→SYSTEM→ControlSet002→services→OracleMTSRecoveryService 其他节点的对应位置 修改完成后点击确定关闭提示窗口继续安装 若是初次安装时提示无法启动OracleMTSRecoveryService服务，则在cluster2节点打开Win+R，“（输入）services.msc→（找到）OracleRemExecService “，若ImagePath中的路径在Temp后有两个\\，则删除后刷新注册表（重启explorer）,返回cluster1节点点击重试即可 5、数据库创建失败 ‘dbca’ 不是内部或外部命令，也不是可运行的程序或批处理文件： 重启cmd，若仍找不到命令请确定RDBMS安装正确 配置em失败，提示如下： 该问题未知明确的解决流程，首先尝试重新运行dbca，若再次失败则按照提示运行使用emca脚本，命令为 emca -config dbcontrol db -repos create 按照提示输入 确定后可能提示实例不存在或其他错误，返回重新执行dbca，若依旧失败需自行寻找解决办法 已明确的： ​ 不需要配置监听程序，即使查看监听程序不存在 ​ 此时emca执行失败是正常的，create或是recreate ​ 大概率在emca失败后重新执行dbca可以解决该问题（可能的原因，emca执行过程中创建了监听器等dbca所需的环境） 6、登录失败 若确定用户名&#x2F;密码正确，尝试重启cluster 重启后执行crsctl check crs，确定连接正常后再行尝试登录 若依旧失败尝试使用以下命令（administrator账户下） 12345678（1）以sysdba身份登录，不需要提供用户名和密码。 sqlplus /as sysdba ; （2）为用户解锁。alter user system account unlock;（3）重新设定密码。alter user system identified by system123456; 更多任何情况下提示如下问题时： CRS-4639：无法连接 Oracle 高可用性服务，ohasd.bin 未运行或 ohasd.bin 虽在运行但无 init.ohasd 或其他进程 CRS-4530：联系集群同步服务守护进程时出现通信故障，ocssd.bin 未运行 CRS-4535：无法与集群就绪服务通信，crsd.bin 未运行 请检查crsctl check crs是否返回对应服务正常，若刚重启节点，请等待一段时间，否则请重启节点再试 安装完成后的检查项： 123456789crs_stat -t -vsrvctl status listener -n cluster1srvctl status listener -n cluster2srvctl config database -d mersrvctl status database -d mer 参考 RAC11gR2OnWindows.pdf Oracle 11G RAC For Windows 2008 R2部署手册（亲测，成功实施多次） Oracle11gR2 RAC for Windows安装上篇 在安装oracle 11g时，出现执行先决条件失败的情况如下 oracle下system用户解锁和改密码 EM Express不起作用的故障排除 (Doc ID 1604062.1) 监听程序未启动或数据库服务未注册到该监听程序解决方法 net use访问远程电脑 ASM磁盘、目录的管理 安装oracle 11g时出现启动服务出现错误，找不到OracleMTSRecoveryService 以sysdba身份登录oracle报ORA-1031权限不足错误之完美分析 Oracle中sqlplus登录报错SP2-0667和SP2-0750探究","tags":["oracle rac","数据库"]}]